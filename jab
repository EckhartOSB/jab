#!/usr/bin/env ruby
require "rubygems"
require "readline"
gem "xmpp4r"
require "xmpp4r/client"
require "xmpp4r/roster"
include Jabber

$requests = []
$colors = []
$op = nil
$notify = {:errors => true, :info => true, :jabs => true, :status => true, :always => true}
$accept = :ask
begin
  Readline.vi_editing_mode
rescue NotImplementedError
  interject :info, "vi editing mode not available"
end

class Sandbox
  def binding
    (Proc.new {}).binding
  end
end

class Object
  def method_missing(sym, *args)
    args.unshift(sym.to_s).join(' ')
  end
end

def ask(prompt, silent=nil, call=nil)
  system 'stty -echo' if silent
  /.*`(.*)'/ =~ (call ? call : caller[0])
  say $1 ? "(#{$1}) #{prompt}: " : "#{prompt}: "
  res = Readline.readline('', true)
  system('stty echo') && puts('') if silent
  res ? res.chomp : res
end

def multiask(choices, default=nil, call=nil)
   Readline.completion_append_character = nil
   Readline.completion_proc = proc {|s| choices.grep(/^#{Regexp.escape(s)}/) }
   r = ''
   begin
     prompt = choices.join('/')
     prompt.sub!(/\b#{default}\b/, "[#{default}]") if default
     r = ask(prompt, nil, (call ? call : caller[0]))
     r = default if default && r && (r == '')
   end until (!r || choices.include?(r))
   r
end

def say(what)
  s = what
  $colors.each do |cla|
    s.gsub! *cla
  end
  print s
end

def interject(type, sender, msg)
  say ">#{sender || ''} #{msg}\n" if $notify[type]
end

def connect(user=nil, password=nil)
  id = user || ask("user@domain/resource")
  if id
    pw = password || ask("password", true)
    if pw
      say ">connecting..." if $notify[:info]
      $stdout.flush
      jid = JID::new id
      $client = Client::new jid
      $client.connect
      $client.auth pw
      $client.add_message_callback do |m|
	case m.type
	  when :chat || :normal
	    if m.body
	      interject :jabs, m.from, 'jabs: ' + m.body
	    end
	  when :error
	    interject :errors, m.from, 'ducked your jab:' + m.to_s.gsub(/<\/\w+>/,'').gsub(/\/?>/,'').gsub(/</,"\n>").gsub(/xmlns=(['"]).+?\1/,'')
	end
      end
      $roster = Roster::Helper.new $client
      $roster.add_subscription_request_callback do |item,pres|
	case $accept
	  when :ask
	    $requests << pres
	  when :y
	    $roster.accept_subscription pres.from
	    tap pres.from
	    interject :status, pres.from, "can now jab you"
	  when :n
	    $roster.decline_subscription pres.from
	    interject :status, pres.from, "denied"
	end
      end
      $roster.add_subscription_callback do |roster,pres|
	interject :status, pres.from, "is now jabbable" if pres.type == :subscribed
      end
      $roster.add_presence_callback do |roster, old, new|
	interject :status, new.from, 'is ' + (new.show ? new.show.to_s : 'available') + (new.status ? ': ' + new.status : '')
      end
      say "done.\n" if $notify[:info]
    else
      exit 1
    end
  else
    exit 1
  end
end

def handle_requests
  while pres = $requests.shift
    interject :always, pres.from, "wants to be able to jab you.\n>the question is, do you want to be jabbed? "
    ans = multiask(['y','n'], nil, '')
    if ans && (ans == 'y')
      interject :info, pres.from, "-- come on in!"
      $roster.accept_subscription pres.from
      tap pres.from
    else
      interject :info, pres.from, "-- rejected!"
      $roster.decline_subscription pres.from
    end
  end
  true
end

def jab(user=nil, message=nil)
  who = user || ask("whom")
  if who
    if message
      m = Message::new who, message
      m.type = :chat
      $client.send m
    else
      while msg = ask(who)
	if msg.length > 0
	  m = Message::new who, msg
	  m.type = :chat
	  $client.send m
        end
      end
      puts ''
    end
  end
end

def tap(user=nil)
  who = user || ask("whom")
  $client.send Presence.new.set_type(:subscribe).set_to(who) if who
end

def shove(user=nil)
  who = user || ask("whom")
  $client.send Presence.new.set_type(:unsubscribe).set_to(who) if who
end

def status(sts=nil, msg=nil)
  s = sts || multiask(['away','chat','dnd','xa'], 'chat')
  if s
    pres = Presence.new
    pres.show = s.to_sym
    pres.status = msg || ask("message [none]")
    $client.send pres
  end
end

def notify(what, on)
  w = what || multiask(['all','errors','info','jabs','status'], nil, caller[0])
  if w
    w = w.to_sym
    if w == :all
      $notify[:errors] = on
      $notify[:info] = on
      $notify[:jabs] = on
      $notify[:status] = on
    else
      $notify[w] = on
    end
  end
end

def hush(what=nil)
  notify(what, false)
end

def unhush(what=nil)
  notify(what, true)
end

def when_tapped(action=nil)
  a = action || multiask(['ask','n','y'], 'ask')
  $accept = a.to_sym if a
end

def source(file=nil, ignore_fnf=nil)
  f = file || ask("filename")
  if f
    f = File.expand_path(f)
    if (!ignore_fnf) || (File.exists? f)
      File.open f do |fd|
	begin
	  eval fd.readlines.join, $sandbox, file
	rescue Exception => exc
	  interject :errors, nil, "error in #{file}\n>#{$!}"
	end
      end
    end
  end
end

def get_color(cap, c)
   cn = ["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white", "grey"].index(c.to_s.downcase) || c.to_i
   $numcolors ||= `tput Co`.to_i
   raise "color #{cn} not supported by terminal" if cn >= $numcolors
   `tput #{cap} #{cn}`
end

def fg(c)
   get_color('AF',c) if c
end

def bg(c)
   get_color('AB',c) if c
end

def color(what,*how)
  if how.size > 0
    $op ||= `tput op`
    $colors << [Regexp.new(what), how.join('') + '\0' + $op]
  end
end

def about
  say "jab version 0.1, by chip camden\n"
  say "http://chipstips.com/?tag=rbjab\n"
end

def help
  about
  say <<END

commands:

about						information about jab
color pattern [sequence...]			prefix pattern with sequence
connect ["user@domain/resource"] ["password"]	connect to XMPP server
help						print this list
hush [type]					suppress certain messages
jab [user] [message]				send a message
q						exit
shove [user]					unsubscribe from user
source [file] [ignore_fnf]			read file for commands
status [sts] [message]				set availability status
tap [user]					request subscription to user
unhush [type]					allow certain messages
when_tapped [action]				how to handle sub requests
<eof>						exit

Most optional parameters not supplied will be requested.  Additionally,
you can use any Ruby statements, which will be executed within a
sandboxed binding.  Thus, for example, to establish a user alias:

chip = "sterlingcamden@jabber.org"

which creates the variable chip in the sandboxed context.  Now you can:

jab chip

If the file ~/.jabrc exists, it will be evaluated prior to asking you
for commands.

If an identifier is not recognized, it will be converted into its string
equivalent.  Thus, by default, red = "red".

Autocompletion is enabled when asked a multiple-choice question.  Just
press Tab.

Sequences for the color command can be generated from termcap using the
addtional commands 'fg' and 'bg', which each take a color name or number
as an argument.  The only names recognized are "black", "red", "green",
"blue", "magenta", "cyan", "white", and "grey" -- but you can pass any
color number that is supported by the termcap entry for your terminal
type.  This capability relies on being able to execute 'tput'.

Examples:

color /^:/ , fg(blue)					# prompt blue
color /^>.*ducked your jab:.*/ , bg(red), fg(white)	# flag errors
color /^>\#{chip}\\S* jabs:.*/m , fg(226)			# jabs from chip
color /^>\\S* is .*/ , fg(grey)				# status changes

END
end

def q
  exit
end

#Jabber::debug = true

$sandbox = Sandbox.new.binding

source "~/.jabrc", true

connect if !$client

while handle_requests && (cmd = ask(''))
  begin
    eval cmd, $sandbox
  rescue SystemExit => exc
    break
  rescue Exception => exc
    interject :errors, nil, "error evaluating command '#{cmd}'\n>#{$!}"
  end
end
